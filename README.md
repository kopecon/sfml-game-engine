# SFML Game Engine

A personal **C++ game architecture project**, built as a learning exercise to explore modern C++, low-level design decisions, and foundational game development concepts using **SFML (Simple and Fast Multimedia Library)**.

This project is intentionally experimental and iterative. It prioritizes **understanding, refactoring, and architectural reasoning** over feature completeness or production polish.

---

## Overview

This repository represents a long-form practice effort focused on building a small game framework from scratch rather than relying on pre-made engines or abstractions.

Key learning goals include:

- Modern C++ (C++20+) language features and idioms
- Explicit ownership and lifetime management
- Scene graph and render hierarchies
- State machines and behavior modeling
- Input handling strategies (event-based vs real-time)
- Separation of concerns between systems (input, rendering, logic)
- Practical use of SFML for graphics, windowing, and events
- CMake-based build configuration

The project evolved through multiple refactors as understanding deepened, and many design decisions reflect **trade-offs discovered during implementation** rather than textbook solutions.

---

## Learning Approach

- Built primarily as a **learning and experimentation project**
- Emphasis on:
  - Clear ownership semantics
  - Minimal but intentional abstractions
  - Avoiding “magic” behavior
- Comments are kept minimal to encourage **self-explanatory code**
- Refactoring is frequent and expected
- Commit history reflects experimentation rather than a polished workflow
- **ChatGPT was used strictly as a feedback and discussion tool**, never for direct code generation

---

## Architectural Highlights

While not a full engine, the project explores several core engine concepts:

### Entity & Component Structure
- Entities represent high-level game objects
- Responsibilities are split into focused components (rendering, input, physics, state, etc.)
- Strong attention to ownership and reference safety

### State Machine System
- Templated, enum-driven state machines
- Explicit state transitions with guarded edges
- Clear separation between:
  - State logic
  - Transition conditions
  - Side effects (enter/exit)

### Rendering & Scene Graph
- Custom scene graph built on top of SFML
- Hierarchical `Composite` system with:
  - Local vs global transforms
  - Proper bounds propagation
  - Child-parent relationships
- Rendering handled explicitly through traversal

### Input Handling
- Exploration of:
  - Event-based input (SFML events)
  - Real-time polling
- Custom input abstraction to unify both approaches
- Subscription-based event dispatching
- Explicit lifetime management to avoid dangling handlers

### Animation & Timing
- Animation engines decoupled from rendering
- State-driven animation selection
- Frame-based and time-based updates

---

## Technologies

- **C++ (C++20+)**
- **SFML** (graphics, windowing, input)
- **CMake** (build system)

---

## What This Project Demonstrates

- Independent learning of a systems programming language
- Practical understanding of game loops and frame updates
- Experience with low-level graphics APIs
- Comfort with templates, RAII, references, and ownership
- Willingness to refactor and question architectural decisions
- Focus on correctness, clarity, and maintainability over shortcuts

---

## Status

This project is **ongoing and experimental**.

Expect:
- Incomplete systems
- Refactors that change architecture
- Design decisions that evolve over time

That evolution is intentional and part of the learning process.

---

- README generated by ChatGPT and reviewed by kopecon.
